Yes, building a small Rust app that directly generates and writes static HTML files—while using an embedded database like Sled for lightweight key-value storage or Postgres for more structured relational data—can indeed be one of the simplest and most reliable ("rock solid") approaches for a personal project like your chess imageboard. This hybrid setup combines the performance of static serving with the organization of a database, without the overhead of a full dynamic web server. It's particularly appealing for minimalism, as Rust's type safety, compilation checks, and lack of runtime dependencies make the app crash-resistant and secure by default. Below, I'll explain why this works well, how it could look in practice (conceptually, based on real Rust patterns and examples from similar projects), and the trade-offs between Sled and Postgres.
Why This Approach is Simple and Rock Solid

Core Idea: Your app acts as a static site generator (SSG). It stores content (e.g., posts, threads) in a database instead of scattered files or a full web framework. When a post is added/updated (via a command-line interface or simple endpoint), the app queries the DB, renders HTML using templates, and writes static files to a directory (e.g., dist/ or public/). A web server like Nginx then serves those files directly—super fast, no DB hits per visitor.
This is inspired by minimal Rust SSGs like Yachiru (a ~100-line project on GitHub that parses Markdown and outputs HTML using crates like Comrak for rendering and Tera for templates). Similar tutorials and videos show SSGs in under 150 lines of Rust, focusing on input data → render → write files.
Reliability: No runtime interpretation (like PHP in Vichan/TinyIB)—everything compiles to a single binary. Sled/Postgres handle persistence safely, with transactions to prevent partial writes. Under load, static files scale infinitely via CDNs, and the app itself is just for generation (run it offline or on-demand).
Security: Minimal attack surface—no exposed DB, no user inputs during serving. Rust prevents common errors like buffer overflows.
Speed: Generation is fast (milliseconds per page), and serving static HTML is as quick as Vichan/TinyIB's file-based modes (sub-10ms responses).

Advantages Over Pure Dynamic or File-Only Systems:
Vs. Dynamic (like your current Axum setup): No per-request DB queries/rendering—generate once, serve forever. Handles heavy load better without caching layers.
Vs. Pure Files (like TinyIB flatfiles): DB adds structure (e.g., query by thread_id), easier backups/searches, and atomic updates. No manual file parsing.
Rock Solid Factor: The app could be a single binary you run manually (e.g., cargo run -- generate) or via a cron job for auto-rebuilds. No external services needed if using Sled.


How It Could Work in a Small Rust App
Conceptually, your main.rs stays compact (~200-300 lines total). Use crates like:

tera for HTML templates (simple, fast).
comrak or pulldown-cmark for Markdown rendering (if posts have formatted text).
sled or sqlx (for Postgres) for storage.
std::fs to write files.
With Sled (Embedded KV Store—Simplest for Minimalism):
Sled is a Rust-native, file-based DB (no separate server)—perfect for "rock solid" as it's embedded in your binary.
Store posts as serialized structs (e.g., using bincode or serde_json): Key = "thread:1", Value = JSON of posts.
Generation: Open Sled DB → Iterate keys → Render each thread to HTML → Write to dist/thread-1.html.
Example Flow:
Add post: App inserts to Sled, then regenerates affected HTML files.
Full rebuild: Loop over all threads, render, write.

Why Rock Solid: No network/DB process—app is self-contained. Crashes? Sled recovers via WAL (write-ahead log). Size: Handles GBs easily for your use.

With Postgres (Relational—If You Need Queries/Structure):
Use your existing SQLx setup to store posts/threads in tables.
Generation: Query "SELECT * FROM posts ORDER BY bump_timestamp" → Group by thread → Render to HTML → Write files.
Example Flow: Similar to Sled, but with SQL queries. Run the app as a one-off command after changes.
Why Rock Solid: Transactions ensure consistent writes; migrations handle schema changes without losing data. But it requires a running Postgres server (e.g., via Docker), adding a tiny bit more setup than Sled.

Adding Features Like Your Chess Board:
Store threads/posts in DB.
Render: Use templates for board layouts, embed JS for PGN later.
Output: Static files like dist/index.html (board catalog), dist/thread-1.html.
Moderation: Simple CLI commands (e.g., app delete thread 1) that update DB and regenerate files.


Real examples: Projects like Yachiru (GitHub) show this in <100 lines without a DB, but adding Sled/Postgres is straightforward (e.g., replace file reading with DB queries). Tutorials (e.g., on Rust forums or YouTube) demonstrate SSGs in ~100 lines; Stack Overflow has Sled serialization snippets to adapt.
Trade-Offs and When to Choose Sled vs. Postgres

Sled (Recommended for Simplest/Rock Solid): Least code/deps, fully embedded (app = one file), fastest startup. Ideal if your data is simple (key-value posts). Cons: Less querying power (no SQL joins).
Postgres: More structured (e.g., relations between threads/posts), easier for complex searches. Cons: Needs a DB server (extra process), slightly more code for connections.
Under Load: Both generate static files, so serving is identical/fast. Generation itself is offline, so no load impact.
Migration: If you switch later (e.g., from files to DB), export/import data—easy with Rust tools.

This is simpler than Vichan/TinyIB in code size while being more modern/safe. If you prototype it, start with Sled for pure minimalism!